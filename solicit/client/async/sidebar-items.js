initSidebarItems({"enum":[["ClientServiceErr","An enum that represents errors that can be raised by the operation of a `ClientService`."],["WorkItem","An enum representing the types of work that the `ClientService` can perform from within its `run_once` method."]],"struct":[["AsyncRequest","A struct representing an asynchronously dispatched request. It is used internally be the `ClientService` and `Client` structs."],["ChannelFrameReceiver","A struct that buffers `HttpFrame`s read by the wrapped `ReceiveFrame` instance in an internal `mpsc` channel. The reads from the wrapped `ReceiveFrame` instance are triggered by calls to the `read_next` method."],["ChannelFrameReceiverHandle","A handle to the `ChannelFrameReceiver` and an implementation of the `ReceiveFrame` trait. It simply pops the next frame from the internal channel that buffers the frames read by the `ReceiveFrame` instance wrapped by the associated `ChannelFrameReceiver`. If there are no frames currently buffered, it blocks until there is one. Therefore, the `handle_next_frame` method of the `HttpConnection` that relies on the IO provided by this `ReceiveFrame` implementation should be triggered only when sure that there are buffered frames, if blocking handles are to be avoided."],["ChannelFrameSender","A struct that buffers `RawFrame`s in an internal `mpsc` channel and sends them using the wrapped `SendFrame` instance when the `send_next` method is called."],["ChannelFrameSenderHandle","A handle to the `ChannelFrameSender` and an implementation of the `SendFrame` trait. It simply queues the given frames into the send queue of the `ChannelFrameSender` without ever blocking. (Except possibly to allocate some memory, as per the `mpsc::channel` specification.)"],["Client","A struct representing an HTTP/2 client that receives responses to its requests asynchronously. Additionally, this client can be cloned and all clones can issue (concurrently) requests to the server, using the same underlying HTTP/2 connection."],["ClientService","An internal struct encapsulating a service that lets multiple clients issue concurrent requests to the same HTTP/2 connection."],["Service","A helper wrapper around the components of the `ClientService` that are returned from its constructor."]]});