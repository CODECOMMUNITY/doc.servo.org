<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `Fragment` struct in crate `layout`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, Fragment">

    <title>layout::fragment::Fragment - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='../index.html'>layout</a>::<wbr><a href='index.html'>fragment</a></p><script>window.sidebarCurrent = {name: 'Fragment', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='../index.html'>layout</a>::<wbr><a href='index.html'>fragment</a>::<wbr><a class='struct' href=''>Fragment</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-4943' class='srclink' href='../../src/layout/fragment.rs.html#81-130' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct Fragment {
    pub node: <a class='struct' href='../../style/dom/struct.OpaqueNode.html' title='style::dom::OpaqueNode'>OpaqueNode</a>,
    pub style: <a class='struct' href='../../alloc/arc/struct.Arc.html' title='alloc::arc::Arc'>Arc</a>&lt;<a class='struct' href='../../style/properties/struct.ServoComputedValues.html' title='style::properties::ServoComputedValues'>ServoComputedValues</a>&gt;,
    pub selected_style: <a class='struct' href='../../alloc/arc/struct.Arc.html' title='alloc::arc::Arc'>Arc</a>&lt;<a class='struct' href='../../style/properties/struct.ServoComputedValues.html' title='style::properties::ServoComputedValues'>ServoComputedValues</a>&gt;,
    pub border_box: <a class='struct' href='../../style/logical_geometry/struct.LogicalRect.html' title='style::logical_geometry::LogicalRect'>LogicalRect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;,
    pub border_padding: <a class='struct' href='../../style/logical_geometry/struct.LogicalMargin.html' title='style::logical_geometry::LogicalMargin'>LogicalMargin</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;,
    pub margin: <a class='struct' href='../../style/logical_geometry/struct.LogicalMargin.html' title='style::logical_geometry::LogicalMargin'>LogicalMargin</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;,
    pub specific: <a class='enum' href='../../layout/fragment/enum.SpecificFragmentInfo.html' title='layout::fragment::SpecificFragmentInfo'>SpecificFragmentInfo</a>,
    pub inline_context: <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../../layout/inline/struct.InlineFragmentContext.html' title='layout::inline::InlineFragmentContext'>InlineFragmentContext</a>&gt;,
    pub restyle_damage: <a class='struct' href='../../layout/incremental/struct.RestyleDamage.html' title='layout::incremental::RestyleDamage'>RestyleDamage</a>,
    pub pseudo: <a class='enum' href='../../layout/wrapper/enum.PseudoElementType.html' title='layout::wrapper::PseudoElementType'>PseudoElementType</a>&lt;<a class='primitive' href='../../std/primitive.tuple.html'>()</a>&gt;,
    pub flags: <a class='struct' href='../../layout/fragment/struct.FragmentFlags.html' title='layout::fragment::FragmentFlags'>FragmentFlags</a>,
    debug_id: <a class='struct' href='../../layout/fragment/struct.DebugId.html' title='layout::fragment::DebugId'>DebugId</a>,
    pub stacking_context_id: <a class='struct' href='../../gfx_traits/struct.StackingContextId.html' title='gfx_traits::StackingContextId'>StackingContextId</a>,
}</pre><div class='docblock'><p>Fragments (<code>struct Fragment</code>) are the leaves of the layout tree. They cannot position
themselves. In general, fragments do not have a simple correspondence with CSS fragments in the
specification:</p>

<ul>
<li><p>Several fragments may correspond to the same CSS box or DOM node. For example, a CSS text box
broken across two lines is represented by two fragments.</p></li>
<li><p>Some CSS fragments are not created at all, such as some anonymous block fragments induced by
inline fragments with block-level sibling fragments. In that case, Servo uses an <code>InlineFlow</code>
with <code>BlockFlow</code> siblings; the <code>InlineFlow</code> is block-level, but not a block container. It is
positioned as if it were a block fragment, but its children are positioned according to
inline flow.</p></li>
</ul>

<p>A <code>SpecificFragmentInfo::Generic</code> is an empty fragment that contributes only borders, margins,
padding, and backgrounds. It is analogous to a CSS nonreplaced content box.</p>

<p>A fragment&#39;s type influences how its styles are interpreted during layout. For example,
replaced content such as images are resized differently from tables, text, or other content.
Different types of fragments may also contain custom data; for example, text fragments contain
text.</p>

<p>Do not add fields to this structure unless they&#39;re really really mega necessary! Fragments get
moved around a lot and thus their size impacts performance of layout quite a bit.</p>

<p>FIXME(#2260, pcwalton): This can be slimmed down some by (at least) moving <code>inline_context</code>
to be on <code>InlineFlow</code> only.</p>
</div><h2 class='fields'>Fields</h2><span id='structfield.node'><code>node: <a class='struct' href='../../style/dom/struct.OpaqueNode.html' title='style::dom::OpaqueNode'>OpaqueNode</a></code></span>
                           <span class='stab '></span><div class='docblock'><p>An opaque reference to the DOM node that this <code>Fragment</code> originates from.</p>
</div><span id='structfield.style'><code>style: <a class='struct' href='../../alloc/arc/struct.Arc.html' title='alloc::arc::Arc'>Arc</a>&lt;<a class='struct' href='../../style/properties/struct.ServoComputedValues.html' title='style::properties::ServoComputedValues'>ServoComputedValues</a>&gt;</code></span>
                           <span class='stab '></span><div class='docblock'><p>The CSS style of this fragment.</p>
</div><span id='structfield.selected_style'><code>selected_style: <a class='struct' href='../../alloc/arc/struct.Arc.html' title='alloc::arc::Arc'>Arc</a>&lt;<a class='struct' href='../../style/properties/struct.ServoComputedValues.html' title='style::properties::ServoComputedValues'>ServoComputedValues</a>&gt;</code></span>
                           <span class='stab '></span><div class='docblock'><p>The CSS style of this fragment when it&#39;s selected</p>
</div><span id='structfield.border_box'><code>border_box: <a class='struct' href='../../style/logical_geometry/struct.LogicalRect.html' title='style::logical_geometry::LogicalRect'>LogicalRect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;</code></span>
                           <span class='stab '></span><div class='docblock'><p>The position of this fragment relative to its owning flow. The size includes padding and
border, but not margin.</p>

<p>NB: This does not account for relative positioning.
NB: Collapsed borders are not included in this.</p>
</div><span id='structfield.border_padding'><code>border_padding: <a class='struct' href='../../style/logical_geometry/struct.LogicalMargin.html' title='style::logical_geometry::LogicalMargin'>LogicalMargin</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;</code></span>
                           <span class='stab '></span><div class='docblock'><p>The sum of border and padding; i.e. the distance from the edge of the border box to the
content edge of the fragment.</p>
</div><span id='structfield.margin'><code>margin: <a class='struct' href='../../style/logical_geometry/struct.LogicalMargin.html' title='style::logical_geometry::LogicalMargin'>LogicalMargin</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;</code></span>
                           <span class='stab '></span><div class='docblock'><p>The margin of the content box.</p>
</div><span id='structfield.specific'><code>specific: <a class='enum' href='../../layout/fragment/enum.SpecificFragmentInfo.html' title='layout::fragment::SpecificFragmentInfo'>SpecificFragmentInfo</a></code></span>
                           <span class='stab '></span><div class='docblock'><p>Info specific to the kind of fragment. Keep this enum small.</p>
</div><span id='structfield.inline_context'><code>inline_context: <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../../layout/inline/struct.InlineFragmentContext.html' title='layout::inline::InlineFragmentContext'>InlineFragmentContext</a>&gt;</code></span>
                           <span class='stab '></span><div class='docblock'><p>Holds the style context information for fragments that are part of an inline formatting
context.</p>
</div><span id='structfield.restyle_damage'><code>restyle_damage: <a class='struct' href='../../layout/incremental/struct.RestyleDamage.html' title='layout::incremental::RestyleDamage'>RestyleDamage</a></code></span>
                           <span class='stab '></span><div class='docblock'><p>How damaged this fragment is since last reflow.</p>
</div><span id='structfield.pseudo'><code>pseudo: <a class='enum' href='../../layout/wrapper/enum.PseudoElementType.html' title='layout::wrapper::PseudoElementType'>PseudoElementType</a>&lt;<a class='primitive' href='../../std/primitive.tuple.html'>()</a>&gt;</code></span>
                           <span class='stab '></span><div class='docblock'><p>The pseudo-element that this fragment represents.</p>
</div><span id='structfield.flags'><code>flags: <a class='struct' href='../../layout/fragment/struct.FragmentFlags.html' title='layout::fragment::FragmentFlags'>FragmentFlags</a></code></span>
                           <span class='stab '></span><div class='docblock'><p>Various flags for this fragment.</p>
</div><span id='structfield.debug_id'><code>debug_id: <a class='struct' href='../../layout/fragment/struct.DebugId.html' title='layout::fragment::DebugId'>DebugId</a></code></span>
                           <span class='stab '></span><div class='docblock'><p>A debug ID that is consistent for the life of this fragment (via transform etc).
This ID should not be considered stable across multiple layouts or fragment
manipulations.</p>
</div><span id='structfield.stacking_context_id'><code>stacking_context_id: <a class='struct' href='../../gfx_traits/struct.StackingContextId.html' title='gfx_traits::StackingContextId'>StackingContextId</a></code></span>
                           <span class='stab '></span><div class='docblock'><p>The ID of the StackingContext that contains this fragment. This is initialized
to 0, but it assigned during the collect_stacking_contexts phase of display
list construction.</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><span class='in-band'><code>impl <a class='struct' href='../../layout/struct.Fragment.html' title='layout::Fragment'>Fragment</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-5535' class='srclink' href='../../src/layout/fragment.rs.html#793-2607' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>&lt;N:&nbsp;<a class='trait' href='../../layout/wrapper/trait.ThreadSafeLayoutNode.html' title='layout::wrapper::ThreadSafeLayoutNode'>ThreadSafeLayoutNode</a>&gt;(node: &amp;N, specific: <a class='enum' href='../../layout/fragment/enum.SpecificFragmentInfo.html' title='layout::fragment::SpecificFragmentInfo'>SpecificFragmentInfo</a>, ctx: &amp;<a class='struct' href='../../layout/context/struct.LayoutContext.html' title='layout::context::LayoutContext'>LayoutContext</a>) -&gt; <a class='struct' href='../../layout/struct.Fragment.html' title='layout::Fragment'>Fragment</a></code></h4>
<div class='docblock'><p>Constructs a new <code>Fragment</code> instance.</p>
</div><h4 id='method.from_opaque_node_and_style' class='method'><code>fn <a href='#method.from_opaque_node_and_style' class='fnname'>from_opaque_node_and_style</a>(node: <a class='struct' href='../../style/dom/struct.OpaqueNode.html' title='style::dom::OpaqueNode'>OpaqueNode</a>, pseudo: <a class='enum' href='../../layout/wrapper/enum.PseudoElementType.html' title='layout::wrapper::PseudoElementType'>PseudoElementType</a>&lt;<a class='primitive' href='../../std/primitive.tuple.html'>()</a>&gt;, style: <a class='struct' href='../../alloc/arc/struct.Arc.html' title='alloc::arc::Arc'>Arc</a>&lt;<a class='struct' href='../../style/properties/struct.ServoComputedValues.html' title='style::properties::ServoComputedValues'>ServoComputedValues</a>&gt;, selected_style: <a class='struct' href='../../alloc/arc/struct.Arc.html' title='alloc::arc::Arc'>Arc</a>&lt;<a class='struct' href='../../style/properties/struct.ServoComputedValues.html' title='style::properties::ServoComputedValues'>ServoComputedValues</a>&gt;, restyle_damage: <a class='struct' href='../../layout/incremental/struct.RestyleDamage.html' title='layout::incremental::RestyleDamage'>RestyleDamage</a>, specific: <a class='enum' href='../../layout/fragment/enum.SpecificFragmentInfo.html' title='layout::fragment::SpecificFragmentInfo'>SpecificFragmentInfo</a>) -&gt; <a class='struct' href='../../layout/struct.Fragment.html' title='layout::Fragment'>Fragment</a></code></h4>
<div class='docblock'><p>Constructs a new <code>Fragment</code> instance from an opaque node.</p>
</div><h4 id='method.transform' class='method'><code>fn <a href='#method.transform' class='fnname'>transform</a>(&amp;self, size: <a class='struct' href='../../style/logical_geometry/struct.LogicalSize.html' title='style::logical_geometry::LogicalSize'>LogicalSize</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, info: <a class='enum' href='../../layout/fragment/enum.SpecificFragmentInfo.html' title='layout::fragment::SpecificFragmentInfo'>SpecificFragmentInfo</a>) -&gt; <a class='struct' href='../../layout/struct.Fragment.html' title='layout::Fragment'>Fragment</a></code></h4>
<div class='docblock'><p>Transforms this fragment into another fragment of the given type, with the given size,
preserving all the other data.</p>
</div><h4 id='method.transform_with_split_info' class='method'><code>fn <a href='#method.transform_with_split_info' class='fnname'>transform_with_split_info</a>(&amp;self, split: &amp;<a class='struct' href='../../layout/fragment/struct.SplitInfo.html' title='layout::fragment::SplitInfo'>SplitInfo</a>, text_run: <a class='struct' href='../../alloc/arc/struct.Arc.html' title='alloc::arc::Arc'>Arc</a>&lt;<a class='struct' href='../../gfx/text/text_run/struct.TextRun.html' title='gfx::text::text_run::TextRun'>TextRun</a>&gt;) -&gt; <a class='struct' href='../../layout/struct.Fragment.html' title='layout::Fragment'>Fragment</a></code></h4>
<div class='docblock'><p>Transforms this fragment using the given <code>SplitInfo</code>, preserving all the other data.</p>
</div><h4 id='method.transform_into_ellipsis' class='method'><code>fn <a href='#method.transform_into_ellipsis' class='fnname'>transform_into_ellipsis</a>(&amp;self, layout_context: &amp;<a class='struct' href='../../layout/context/struct.LayoutContext.html' title='layout::context::LayoutContext'>LayoutContext</a>) -&gt; <a class='struct' href='../../layout/struct.Fragment.html' title='layout::Fragment'>Fragment</a></code></h4>
<div class='docblock'><p>Transforms this fragment into an ellipsis fragment, preserving all the other data.</p>
</div><h4 id='method.restyle_damage' class='method'><code>fn <a href='#method.restyle_damage' class='fnname'>restyle_damage</a>(&amp;self) -&gt; <a class='struct' href='../../layout/incremental/struct.RestyleDamage.html' title='layout::incremental::RestyleDamage'>RestyleDamage</a></code></h4>
<h4 id='method.contains_node' class='method'><code>fn <a href='#method.contains_node' class='fnname'>contains_node</a>(&amp;self, node_address: <a class='struct' href='../../style/dom/struct.OpaqueNode.html' title='style::dom::OpaqueNode'>OpaqueNode</a>) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></code></h4>
<h4 id='method.add_inline_context_style' class='method'><code>fn <a href='#method.add_inline_context_style' class='fnname'>add_inline_context_style</a>(&amp;mut self, node_info: <a class='struct' href='../../layout/inline/struct.InlineFragmentNodeInfo.html' title='layout::inline::InlineFragmentNodeInfo'>InlineFragmentNodeInfo</a>)</code></h4>
<div class='docblock'><p>Adds a style to the inline context for this fragment. If the inline context doesn&#39;t exist
yet, it will be created.</p>
</div><h4 id='method.quantities_included_in_intrinsic_inline_size' class='method'><code>fn <a href='#method.quantities_included_in_intrinsic_inline_size' class='fnname'>quantities_included_in_intrinsic_inline_size</a>(&amp;self) -&gt; <a class='struct' href='../../layout/fragment/struct.QuantitiesIncludedInIntrinsicInlineSizes.html' title='layout::fragment::QuantitiesIncludedInIntrinsicInlineSizes'>QuantitiesIncludedInIntrinsicInlineSizes</a></code></h4>
<div class='docblock'><p>Determines which quantities (border/padding/margin/specified) should be included in the
intrinsic inline size of this fragment.</p>
</div><h4 id='method.surrounding_intrinsic_inline_size' class='method'><code>fn <a href='#method.surrounding_intrinsic_inline_size' class='fnname'>surrounding_intrinsic_inline_size</a>(&amp;self) -&gt; <a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a></code></h4>
<div class='docblock'><p>Returns the portion of the intrinsic inline-size that consists of borders, padding, and/or
margins.</p>

<p>FIXME(#2261, pcwalton): This won&#39;t work well for inlines: is this OK?</p>
</div><h4 id='method.style_specified_intrinsic_inline_size' class='method'><code>fn <a href='#method.style_specified_intrinsic_inline_size' class='fnname'>style_specified_intrinsic_inline_size</a>(&amp;self) -&gt; <a class='struct' href='../../layout/model/struct.IntrinsicISizesContribution.html' title='layout::model::IntrinsicISizesContribution'>IntrinsicISizesContribution</a></code></h4>
<div class='docblock'><p>Uses the style only to estimate the intrinsic inline-sizes. These may be modified for text
or replaced elements.</p>
</div><h4 id='method.guess_inline_content_edge_offsets' class='method'><code>fn <a href='#method.guess_inline_content_edge_offsets' class='fnname'>guess_inline_content_edge_offsets</a>(&amp;self) -&gt; <a class='struct' href='../../layout/fragment/struct.SpeculatedInlineContentEdgeOffsets.html' title='layout::fragment::SpeculatedInlineContentEdgeOffsets'>SpeculatedInlineContentEdgeOffsets</a></code></h4>
<div class='docblock'><p>Returns a guess as to the distances from the margin edge of this fragment to its content
in the inline direction. This will generally be correct unless percentages are involved.</p>

<p>This is used for the float placement speculation logic.</p>
</div><h4 id='method.calculate_line_height' class='method'><code>fn <a href='#method.calculate_line_height' class='fnname'>calculate_line_height</a>(&amp;self, layout_context: &amp;<a class='struct' href='../../layout/context/struct.LayoutContext.html' title='layout::context::LayoutContext'>LayoutContext</a>) -&gt; <a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a></code></h4>
<h4 id='method.border_width' class='method'><code>fn <a href='#method.border_width' class='fnname'>border_width</a>(&amp;self) -&gt; <a class='struct' href='../../style/logical_geometry/struct.LogicalMargin.html' title='style::logical_geometry::LogicalMargin'>LogicalMargin</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;</code></h4>
<div class='docblock'><p>Returns the sum of the inline-sizes of all the borders of this fragment. Note that this
can be expensive to compute, so if possible use the <code>border_padding</code> field instead.</p>
</div><h4 id='method.compute_inline_direction_margins' class='method'><code>fn <a href='#method.compute_inline_direction_margins' class='fnname'>compute_inline_direction_margins</a>(&amp;mut self, containing_block_inline_size: <a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>)</code></h4>
<div class='docblock'><p>Computes the margins in the inline direction from the containing block inline-size and the
style. After this call, the inline direction of the <code>margin</code> field will be correct.</p>

<p>Do not use this method if the inline direction margins are to be computed some other way
(for example, via constraint solving for blocks).</p>
</div><h4 id='method.compute_block_direction_margins' class='method'><code>fn <a href='#method.compute_block_direction_margins' class='fnname'>compute_block_direction_margins</a>(&amp;mut self, containing_block_inline_size: <a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>)</code></h4>
<div class='docblock'><p>Computes the margins in the block direction from the containing block inline-size and the
style. After this call, the block direction of the <code>margin</code> field will be correct.</p>

<p>Do not use this method if the block direction margins are to be computed some other way
(for example, via constraint solving for absolutely-positioned flows).</p>
</div><h4 id='method.compute_border_and_padding' class='method'><code>fn <a href='#method.compute_border_and_padding' class='fnname'>compute_border_and_padding</a>(&amp;mut self, containing_block_inline_size: <a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>, border_collapse: <a class='enum' href='../../style/properties/longhands/border_collapse/computed_value/enum.T.html' title='style::properties::longhands::border_collapse::computed_value::T'>T</a>)</code></h4>
<div class='docblock'><p>Computes the border and padding in both inline and block directions from the containing
block inline-size and the style. After this call, the <code>border_padding</code> field will be
correct.</p>

<p>TODO(pcwalton): Remove <code>border_collapse</code>; we can figure it out from our style and specific
fragment info.</p>
</div><h4 id='method.relative_position' class='method'><code>fn <a href='#method.relative_position' class='fnname'>relative_position</a>(&amp;self, containing_block_size: &amp;<a class='struct' href='../../style/logical_geometry/struct.LogicalSize.html' title='style::logical_geometry::LogicalSize'>LogicalSize</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;) -&gt; <a class='struct' href='../../style/logical_geometry/struct.LogicalSize.html' title='style::logical_geometry::LogicalSize'>LogicalSize</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;</code></h4>
<h4 id='method.clear' class='method'><code>fn <a href='#method.clear' class='fnname'>clear</a>(&amp;self) -&gt; <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='enum' href='../../layout/floats/enum.ClearType.html' title='layout::floats::ClearType'>ClearType</a>&gt;</code></h4>
<div class='docblock'><p>Always inline for SCCP.</p>

<p>FIXME(pcwalton): Just replace with the clear type from the style module for speed?</p>
</div><h4 id='method.style' class='method'><code>fn <a href='#method.style' class='fnname'>style</a>(&amp;self) -&gt; &amp;<a class='struct' href='../../style/properties/struct.ServoComputedValues.html' title='style::properties::ServoComputedValues'>ServoComputedValues</a></code></h4>
<h4 id='method.selected_style' class='method'><code>fn <a href='#method.selected_style' class='fnname'>selected_style</a>(&amp;self) -&gt; &amp;<a class='struct' href='../../style/properties/struct.ServoComputedValues.html' title='style::properties::ServoComputedValues'>ServoComputedValues</a></code></h4>
<h4 id='method.white_space' class='method'><code>fn <a href='#method.white_space' class='fnname'>white_space</a>(&amp;self) -&gt; <a class='enum' href='../../style/properties/longhands/white_space/computed_value/enum.T.html' title='style::properties::longhands::white_space::computed_value::T'>T</a></code></h4>
<h4 id='method.text_decoration' class='method'><code>fn <a href='#method.text_decoration' class='fnname'>text_decoration</a>(&amp;self) -&gt; <a class='type' href='../../style/properties/longhands/text_decoration/computed_value/type.T.html' title='style::properties::longhands::text_decoration::computed_value::T'>T</a></code></h4>
<div class='docblock'><p>Returns the text decoration of this fragment, according to the style of the nearest ancestor
element.</p>

<p>NB: This may not be the actual text decoration, because of the override rules specified in
CSS 2.1 § 16.3.1. Unfortunately, computing this properly doesn&#39;t really fit into Servo&#39;s
model. Therefore, this is a best lower bound approximation, but the end result may actually
have the various decoration flags turned on afterward.</p>
</div><h4 id='method.inline_start_offset' class='method'><code>fn <a href='#method.inline_start_offset' class='fnname'>inline_start_offset</a>(&amp;self) -&gt; <a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a></code></h4>
<div class='docblock'><p>Returns the inline-start offset from margin edge to content edge.</p>

<p>FIXME(#2262, pcwalton): I think this method is pretty bogus, because it won&#39;t work for
inlines.</p>
</div><h4 id='method.can_split' class='method'><code>fn <a href='#method.can_split' class='fnname'>can_split</a>(&amp;self) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if this element can be split. This is true for text fragments, unless
<code>white-space: pre</code> or <code>white-space: nowrap</code> is set.</p>
</div><h4 id='method.is_unscanned_generated_content' class='method'><code>fn <a href='#method.is_unscanned_generated_content' class='fnname'>is_unscanned_generated_content</a>(&amp;self) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if and only if this fragment is a generated content fragment.</p>
</div><h4 id='method.is_scanned_text_fragment' class='method'><code>fn <a href='#method.is_scanned_text_fragment' class='fnname'>is_scanned_text_fragment</a>(&amp;self) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if and only if this is a scanned text fragment.</p>
</div><h4 id='method.compute_intrinsic_inline_sizes' class='method'><code>fn <a href='#method.compute_intrinsic_inline_sizes' class='fnname'>compute_intrinsic_inline_sizes</a>(&amp;mut self) -&gt; <a class='struct' href='../../layout/model/struct.IntrinsicISizesContribution.html' title='layout::model::IntrinsicISizesContribution'>IntrinsicISizesContribution</a></code></h4>
<div class='docblock'><p>Computes the intrinsic inline-sizes of this fragment.</p>
</div><h4 id='method.minimum_splittable_inline_size' class='method'><code>fn <a href='#method.minimum_splittable_inline_size' class='fnname'>minimum_splittable_inline_size</a>(&amp;self) -&gt; <a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a></code></h4>
<div class='docblock'><p>Returns the narrowest inline-size that the first splittable part of this fragment could
possibly be split to. (In most cases, this returns the inline-size of the first word in
this fragment.)</p>
</div><h4 id='method.content_inline_size' class='method'><code>fn <a href='#method.content_inline_size' class='fnname'>content_inline_size</a>(&amp;self) -&gt; <a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a></code></h4>
<div class='docblock'><p>TODO: What exactly does this function return? Why is it Au(0) for
<code>SpecificFragmentInfo::Generic</code>?</p>
</div><h4 id='method.content_box' class='method'><code>fn <a href='#method.content_box' class='fnname'>content_box</a>(&amp;self) -&gt; <a class='struct' href='../../style/logical_geometry/struct.LogicalRect.html' title='style::logical_geometry::LogicalRect'>LogicalRect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;</code></h4>
<div class='docblock'><p>Returns the dimensions of the content box.</p>

<p>This is marked <code>#[inline]</code> because it is frequently called when only one or two of the
values are needed and that will save computation.</p>
</div><h4 id='method.calculate_split_position' class='method'><code>fn <a href='#method.calculate_split_position' class='fnname'>calculate_split_position</a>(&amp;self, max_inline_size: <a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>, starts_line: <a class='primitive' href='../../std/primitive.bool.html'>bool</a>) -&gt; <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../../layout/fragment/struct.SplitResult.html' title='layout::fragment::SplitResult'>SplitResult</a>&gt;</code></h4>
<div class='docblock'><p>Attempts to find the split positions of a text fragment so that its inline-size is no more
than <code>max_inline_size</code>.</p>

<p>A return value of <code>None</code> indicates that the fragment could not be split. Otherwise the
information pertaining to the split is returned. The inline-start and inline-end split
information are both optional due to the possibility of them being whitespace.</p>
</div><h4 id='method.truncate_to_inline_size' class='method'><code>fn <a href='#method.truncate_to_inline_size' class='fnname'>truncate_to_inline_size</a>(&amp;self, max_inline_size: <a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>) -&gt; <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../../layout/fragment/struct.TruncationResult.html' title='layout::fragment::TruncationResult'>TruncationResult</a>&gt;</code></h4>
<div class='docblock'><p>Truncates this fragment to the given <code>max_inline_size</code>, using a character-based breaking
strategy. If no characters could fit, returns <code>None</code>.</p>
</div><h4 id='method.calculate_split_position_using_breaking_strategy' class='method'><code>fn <a href='#method.calculate_split_position_using_breaking_strategy' class='fnname'>calculate_split_position_using_breaking_strategy</a>&lt;'a,&nbsp;I&gt;(&amp;self, slice_iterator: I, max_inline_size: <a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>, flags: <a class='struct' href='../../layout/fragment/struct.SplitOptions.html' title='layout::fragment::SplitOptions'>SplitOptions</a>) -&gt; <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../../layout/fragment/struct.SplitResult.html' title='layout::fragment::SplitResult'>SplitResult</a>&gt; <span class='where'>where I: <a class='trait' href='../../core/iter/iterator/trait.Iterator.html' title='core::iter::iterator::Iterator'>Iterator</a>&lt;Item=<a class='struct' href='../../gfx/text/text_run/struct.TextRunSlice.html' title='gfx::text::text_run::TextRunSlice'>TextRunSlice</a>&lt;'a&gt;&gt;</span></code></h4>
<div class='docblock'><p>A helper method that uses the breaking strategy described by <code>slice_iterator</code> (at present,
either natural word breaking or character breaking) to split this fragment.</p>
</div><h4 id='method.merge_with' class='method'><code>fn <a href='#method.merge_with' class='fnname'>merge_with</a>(&amp;mut self, next_fragment: <a class='struct' href='../../layout/struct.Fragment.html' title='layout::Fragment'>Fragment</a>)</code></h4>
<div class='docblock'><p>The opposite of <code>calculate_split_position_using_breaking_strategy</code>: merges this fragment
with the next one.</p>
</div><h4 id='method.reset_text_range_and_inline_size' class='method'><code>fn <a href='#method.reset_text_range_and_inline_size' class='fnname'>reset_text_range_and_inline_size</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>Restore any whitespace that was stripped from a text fragment, and recompute inline metrics
if necessary.</p>
</div><h4 id='method.assign_replaced_inline_size_if_necessary' class='method'><code>fn <a href='#method.assign_replaced_inline_size_if_necessary' class='fnname'>assign_replaced_inline_size_if_necessary</a>(&amp;mut self, container_inline_size: <a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>)</code></h4>
<div class='docblock'><p>Assigns replaced inline-size, padding, and margins for this fragment only if it is replaced
content per CSS 2.1 § 10.3.2.</p>
</div><h4 id='method.assign_replaced_block_size_if_necessary' class='method'><code>fn <a href='#method.assign_replaced_block_size_if_necessary' class='fnname'>assign_replaced_block_size_if_necessary</a>(&amp;mut self, containing_block_block_size: <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;)</code></h4>
<div class='docblock'><p>Assign block-size for this fragment if it is replaced content. The inline-size must have
been assigned first.</p>

<p>Ideally, this should follow CSS 2.1 § 10.6.2.</p>
</div><h4 id='method.inline_metrics' class='method'><code>fn <a href='#method.inline_metrics' class='fnname'>inline_metrics</a>(&amp;self, layout_context: &amp;<a class='struct' href='../../layout/context/struct.LayoutContext.html' title='layout::context::LayoutContext'>LayoutContext</a>) -&gt; <a class='struct' href='../../layout/inline/struct.InlineMetrics.html' title='layout::inline::InlineMetrics'>InlineMetrics</a></code></h4>
<div class='docblock'><p>Calculates block-size above baseline, depth below baseline, and ascent for this fragment
when used in an inline formatting context. See CSS 2.1 § 10.8.1.</p>
</div><h4 id='method.is_hypothetical' class='method'><code>fn <a href='#method.is_hypothetical' class='fnname'>is_hypothetical</a>(&amp;self) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if this fragment is a hypothetical box. See CSS 2.1 § 10.3.7.</p>
</div><h4 id='method.can_merge_with_fragment' class='method'><code>fn <a href='#method.can_merge_with_fragment' class='fnname'>can_merge_with_fragment</a>(&amp;self, other: &amp;<a class='struct' href='../../layout/struct.Fragment.html' title='layout::Fragment'>Fragment</a>) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if this fragment can merge with another immediately-following fragment or
false otherwise.</p>
</div><h4 id='method.is_primary_fragment' class='method'><code>fn <a href='#method.is_primary_fragment' class='fnname'>is_primary_fragment</a>(&amp;self) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if and only if this is the <em>primary fragment</em> for the fragment&#39;s style object
(conceptually, though style sharing makes this not really true, of course). The primary
fragment is the one that draws backgrounds, borders, etc., and takes borders, padding and
margins into account. Every style object has at most one primary fragment.</p>

<p>At present, all fragments are primary fragments except for inline-block and table wrapper
fragments. Inline-block fragments are not primary fragments because the corresponding block
flow is the primary fragment, while table wrapper fragments are not primary fragments
because the corresponding table flow is the primary fragment.</p>
</div><h4 id='method.update_late_computed_replaced_inline_size_if_necessary' class='method'><code>fn <a href='#method.update_late_computed_replaced_inline_size_if_necessary' class='fnname'>update_late_computed_replaced_inline_size_if_necessary</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>Determines the inline sizes of inline-block fragments. These cannot be fully computed until
inline size assignment has run for the child flow: thus it is computed &quot;late&quot;, during
block size assignment.</p>
</div><h4 id='method.update_late_computed_inline_position_if_necessary' class='method'><code>fn <a href='#method.update_late_computed_inline_position_if_necessary' class='fnname'>update_late_computed_inline_position_if_necessary</a>(&amp;mut self)</code></h4>
<h4 id='method.update_late_computed_block_position_if_necessary' class='method'><code>fn <a href='#method.update_late_computed_block_position_if_necessary' class='fnname'>update_late_computed_block_position_if_necessary</a>(&amp;mut self)</code></h4>
<h4 id='method.repair_style' class='method'><code>fn <a href='#method.repair_style' class='fnname'>repair_style</a>(&amp;mut self, new_style: &amp;<a class='struct' href='../../alloc/arc/struct.Arc.html' title='alloc::arc::Arc'>Arc</a>&lt;<a class='struct' href='../../style/properties/struct.ServoComputedValues.html' title='style::properties::ServoComputedValues'>ServoComputedValues</a>&gt;)</code></h4>
<h4 id='method.stacking_relative_border_box' class='method'><code>fn <a href='#method.stacking_relative_border_box' class='fnname'>stacking_relative_border_box</a>(&amp;self, stacking_relative_flow_origin: &amp;<a class='struct' href='../../euclid/point/struct.Point2D.html' title='euclid::point::Point2D'>Point2D</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, relative_containing_block_size: &amp;<a class='struct' href='../../style/logical_geometry/struct.LogicalSize.html' title='style::logical_geometry::LogicalSize'>LogicalSize</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, relative_containing_block_mode: <a class='struct' href='../../style/logical_geometry/struct.WritingMode.html' title='style::logical_geometry::WritingMode'>WritingMode</a>, coordinate_system: <a class='enum' href='../../layout/fragment/enum.CoordinateSystem.html' title='layout::fragment::CoordinateSystem'>CoordinateSystem</a>) -&gt; <a class='struct' href='../../euclid/rect/struct.Rect.html' title='euclid::rect::Rect'>Rect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;</code></h4>
<div class='docblock'><p>Given the stacking-context-relative position of the containing flow, returns the border box
of this fragment relative to the parent stacking context. This takes <code>position: relative</code>
into account.</p>

<p>If <code>coordinate_system</code> is <code>Parent</code>, this returns the border box in the parent stacking
context&#39;s coordinate system. Otherwise, if <code>coordinate_system</code> is <code>Own</code> and this fragment
establishes a stacking context itself, this returns a border box anchored at (0, 0). (If
this fragment does not establish a stacking context, then it always belongs to its parent
stacking context and thus <code>coordinate_system</code> is ignored.)</p>

<p>This is the method you should use for display list construction as well as
<code>getBoundingClientRect()</code> and so forth.</p>
</div><h4 id='method.stacking_relative_content_box' class='method'><code>fn <a href='#method.stacking_relative_content_box' class='fnname'>stacking_relative_content_box</a>(&amp;self, stacking_relative_border_box: &amp;<a class='struct' href='../../euclid/rect/struct.Rect.html' title='euclid::rect::Rect'>Rect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;) -&gt; <a class='struct' href='../../euclid/rect/struct.Rect.html' title='euclid::rect::Rect'>Rect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;</code></h4>
<div class='docblock'><p>Given the stacking-context-relative border box, returns the stacking-context-relative
content box.</p>
</div><h4 id='method.establishes_stacking_context' class='method'><code>fn <a href='#method.establishes_stacking_context' class='fnname'>establishes_stacking_context</a>(&amp;self) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if this fragment establishes a new stacking context and false otherwise.</p>
</div><h4 id='method.effective_z_index' class='method'><code>fn <a href='#method.effective_z_index' class='fnname'>effective_z_index</a>(&amp;self) -&gt; <a class='primitive' href='../../std/primitive.i32.html'>i32</a></code></h4>
<h4 id='method.compute_overflow' class='method'><code>fn <a href='#method.compute_overflow' class='fnname'>compute_overflow</a>(&amp;self, flow_size: &amp;<a class='struct' href='../../euclid/size/struct.Size2D.html' title='euclid::size::Size2D'>Size2D</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, relative_containing_block_size: &amp;<a class='struct' href='../../style/logical_geometry/struct.LogicalSize.html' title='style::logical_geometry::LogicalSize'>LogicalSize</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;) -&gt; <a class='struct' href='../../layout/fragment/struct.Overflow.html' title='layout::fragment::Overflow'>Overflow</a></code></h4>
<div class='docblock'><p>Computes the overflow rect of this fragment relative to the start of the flow.</p>
</div><h4 id='method.requires_line_break_afterward_if_wrapping_on_newlines' class='method'><code>fn <a href='#method.requires_line_break_afterward_if_wrapping_on_newlines' class='fnname'>requires_line_break_afterward_if_wrapping_on_newlines</a>(&amp;self) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></code></h4>
<h4 id='method.strip_leading_whitespace_if_necessary' class='method'><code>fn <a href='#method.strip_leading_whitespace_if_necessary' class='fnname'>strip_leading_whitespace_if_necessary</a>(&amp;mut self) -&gt; <a class='enum' href='../../layout/fragment/enum.WhitespaceStrippingResult.html' title='layout::fragment::WhitespaceStrippingResult'>WhitespaceStrippingResult</a></code></h4>
<h4 id='method.strip_trailing_whitespace_if_necessary' class='method'><code>fn <a href='#method.strip_trailing_whitespace_if_necessary' class='fnname'>strip_trailing_whitespace_if_necessary</a>(&amp;mut self) -&gt; <a class='enum' href='../../layout/fragment/enum.WhitespaceStrippingResult.html' title='layout::fragment::WhitespaceStrippingResult'>WhitespaceStrippingResult</a></code></h4>
<div class='docblock'><p>Returns true if the entire fragment was stripped.</p>
</div><h4 id='method.inline_styles' class='method'><code>fn <a href='#method.inline_styles' class='fnname'>inline_styles</a>(&amp;self) -&gt; <a class='struct' href='../../layout/fragment/struct.InlineStyleIterator.html' title='layout::fragment::InlineStyleIterator'>InlineStyleIterator</a></code></h4>
<h4 id='method.margin_box_inline_size' class='method'><code>fn <a href='#method.margin_box_inline_size' class='fnname'>margin_box_inline_size</a>(&amp;self) -&gt; <a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a></code></h4>
<div class='docblock'><p>Returns the inline-size of this fragment&#39;s margin box.</p>
</div><h4 id='method.is_positioned' class='method'><code>fn <a href='#method.is_positioned' class='fnname'>is_positioned</a>(&amp;self) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if this node <em>or any of the nodes within its inline fragment context</em> have
non-<code>static</code> <code>position</code>.</p>
</div><h4 id='method.is_absolutely_positioned' class='method'><code>fn <a href='#method.is_absolutely_positioned' class='fnname'>is_absolutely_positioned</a>(&amp;self) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if this node is absolutely positioned.</p>
</div><h4 id='method.is_inline_absolute' class='method'><code>fn <a href='#method.is_inline_absolute' class='fnname'>is_inline_absolute</a>(&amp;self) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></code></h4>
<h4 id='method.meld_with_next_inline_fragment' class='method'><code>fn <a href='#method.meld_with_next_inline_fragment' class='fnname'>meld_with_next_inline_fragment</a>(&amp;mut self, next_fragment: &amp;<a class='struct' href='../../layout/struct.Fragment.html' title='layout::Fragment'>Fragment</a>)</code></h4>
<h4 id='method.meld_with_prev_inline_fragment' class='method'><code>fn <a href='#method.meld_with_prev_inline_fragment' class='fnname'>meld_with_prev_inline_fragment</a>(&amp;mut self, prev_fragment: &amp;<a class='struct' href='../../layout/struct.Fragment.html' title='layout::Fragment'>Fragment</a>)</code></h4>
<h4 id='method.fragment_id' class='method'><code>fn <a href='#method.fragment_id' class='fnname'>fragment_id</a>(&amp;self) -&gt; <a class='primitive' href='../../std/primitive.usize.html'>usize</a></code></h4>
<h4 id='method.fragment_type' class='method'><code>fn <a href='#method.fragment_type' class='fnname'>fragment_type</a>(&amp;self) -&gt; <a class='enum' href='../../gfx_traits/enum.FragmentType.html' title='gfx_traits::FragmentType'>FragmentType</a></code></h4>
<h4 id='method.layer_id' class='method'><code>fn <a href='#method.layer_id' class='fnname'>layer_id</a>(&amp;self) -&gt; <a class='struct' href='../../gfx_traits/struct.LayerId.html' title='gfx_traits::LayerId'>LayerId</a></code></h4>
<h4 id='method.layer_id_for_overflow_scroll' class='method'><code>fn <a href='#method.layer_id_for_overflow_scroll' class='fnname'>layer_id_for_overflow_scroll</a>(&amp;self) -&gt; <a class='struct' href='../../gfx_traits/struct.LayerId.html' title='gfx_traits::LayerId'>LayerId</a></code></h4>
<h4 id='method.is_vertically_aligned_to_top_or_bottom' class='method'><code>fn <a href='#method.is_vertically_aligned_to_top_or_bottom' class='fnname'>is_vertically_aligned_to_top_or_bottom</a>(&amp;self) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns true if any of the inline styles associated with this fragment have
<code>vertical-align</code> set to <code>top</code> or <code>bottom</code>.</p>
</div><h4 id='method.is_text_or_replaced' class='method'><code>fn <a href='#method.is_text_or_replaced' class='fnname'>is_text_or_replaced</a>(&amp;self) -&gt; <a class='primitive' href='../../std/primitive.bool.html'>bool</a></code></h4>
</div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><span class='in-band'><code>impl <a class='trait' href='../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html' title='layout::display_list_builder::FragmentDisplayListBuilding'>FragmentDisplayListBuilding</a> for <a class='struct' href='../../layout/struct.Fragment.html' title='layout::Fragment'>Fragment</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-2614' class='srclink' href='../../src/layout/display_list_builder.rs.html#335-1665' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.build_display_list_for_background_if_applicable' class='method'><code>fn <a href='../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_display_list_for_background_if_applicable' class='fnname'>build_display_list_for_background_if_applicable</a>(&amp;self, state: &amp;mut <a class='struct' href='../../layout/display_list_builder/struct.DisplayListBuildState.html' title='layout::display_list_builder::DisplayListBuildState'>DisplayListBuildState</a>, style: &amp;<a class='struct' href='../../style/properties/struct.ServoComputedValues.html' title='style::properties::ServoComputedValues'>ServoComputedValues</a>, display_list_section: <a class='enum' href='../../gfx/display_list/enum.DisplayListSection.html' title='gfx::display_list::DisplayListSection'>DisplayListSection</a>, absolute_bounds: &amp;<a class='struct' href='../../euclid/rect/struct.Rect.html' title='euclid::rect::Rect'>Rect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, clip: &amp;<a class='struct' href='../../gfx/display_list/struct.ClippingRegion.html' title='gfx::display_list::ClippingRegion'>ClippingRegion</a>)</code></h4>
<div class='docblock'><p>Adds the display items necessary to paint the background of this fragment to the display list if necessary. <a href="../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_display_list_for_background_if_applicable">Read more</a></p>
</div><h4 id='method.compute_background_image_size' class='method'><code>fn <a href='../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.compute_background_image_size' class='fnname'>compute_background_image_size</a>(&amp;self, style: &amp;<a class='struct' href='../../style/properties/struct.ServoComputedValues.html' title='style::properties::ServoComputedValues'>ServoComputedValues</a>, bounds: &amp;<a class='struct' href='../../euclid/rect/struct.Rect.html' title='euclid::rect::Rect'>Rect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, image: &amp;<a class='struct' href='../../gfx/display_list/struct.WebRenderImageInfo.html' title='gfx::display_list::WebRenderImageInfo'>WebRenderImageInfo</a>) -&gt; <a class='struct' href='../../euclid/size/struct.Size2D.html' title='euclid::size::Size2D'>Size2D</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;</code></h4>
<div class='docblock'><p>Computes the background size for an image with the given background area according to the rules in CSS-BACKGROUNDS § 3.9. <a href="../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.compute_background_image_size">Read more</a></p>
</div><h4 id='method.build_display_list_for_background_image' class='method'><code>fn <a href='../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_display_list_for_background_image' class='fnname'>build_display_list_for_background_image</a>(&amp;self, state: &amp;mut <a class='struct' href='../../layout/display_list_builder/struct.DisplayListBuildState.html' title='layout::display_list_builder::DisplayListBuildState'>DisplayListBuildState</a>, style: &amp;<a class='struct' href='../../style/properties/struct.ServoComputedValues.html' title='style::properties::ServoComputedValues'>ServoComputedValues</a>, display_list_section: <a class='enum' href='../../gfx/display_list/enum.DisplayListSection.html' title='gfx::display_list::DisplayListSection'>DisplayListSection</a>, absolute_bounds: &amp;<a class='struct' href='../../euclid/rect/struct.Rect.html' title='euclid::rect::Rect'>Rect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, clip: &amp;<a class='struct' href='../../gfx/display_list/struct.ClippingRegion.html' title='gfx::display_list::ClippingRegion'>ClippingRegion</a>, image_url: &amp;<a class='struct' href='../../url/struct.Url.html' title='url::Url'>Url</a>)</code></h4>
<div class='docblock'><p>Adds the display items necessary to paint the background image of this fragment to the appropriate section of the display list. <a href="../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_display_list_for_background_image">Read more</a></p>
</div><h4 id='method.build_display_list_for_background_linear_gradient' class='method'><code>fn <a href='../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_display_list_for_background_linear_gradient' class='fnname'>build_display_list_for_background_linear_gradient</a>(&amp;self, state: &amp;mut <a class='struct' href='../../layout/display_list_builder/struct.DisplayListBuildState.html' title='layout::display_list_builder::DisplayListBuildState'>DisplayListBuildState</a>, display_list_section: <a class='enum' href='../../gfx/display_list/enum.DisplayListSection.html' title='gfx::display_list::DisplayListSection'>DisplayListSection</a>, absolute_bounds: &amp;<a class='struct' href='../../euclid/rect/struct.Rect.html' title='euclid::rect::Rect'>Rect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, clip: &amp;<a class='struct' href='../../gfx/display_list/struct.ClippingRegion.html' title='gfx::display_list::ClippingRegion'>ClippingRegion</a>, gradient: &amp;<a class='struct' href='../../style/values/computed/struct.LinearGradient.html' title='style::values::computed::LinearGradient'>LinearGradient</a>, style: &amp;<a class='struct' href='../../style/properties/struct.ServoComputedValues.html' title='style::properties::ServoComputedValues'>ServoComputedValues</a>)</code></h4>
<div class='docblock'><p>Adds the display items necessary to paint the background linear gradient of this fragment to the appropriate section of the display list. <a href="../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_display_list_for_background_linear_gradient">Read more</a></p>
</div><h4 id='method.build_display_list_for_box_shadow_if_applicable' class='method'><code>fn <a href='../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_display_list_for_box_shadow_if_applicable' class='fnname'>build_display_list_for_box_shadow_if_applicable</a>(&amp;self, state: &amp;mut <a class='struct' href='../../layout/display_list_builder/struct.DisplayListBuildState.html' title='layout::display_list_builder::DisplayListBuildState'>DisplayListBuildState</a>, style: &amp;<a class='struct' href='../../style/properties/struct.ServoComputedValues.html' title='style::properties::ServoComputedValues'>ServoComputedValues</a>, display_list_section: <a class='enum' href='../../gfx/display_list/enum.DisplayListSection.html' title='gfx::display_list::DisplayListSection'>DisplayListSection</a>, absolute_bounds: &amp;<a class='struct' href='../../euclid/rect/struct.Rect.html' title='euclid::rect::Rect'>Rect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, clip: &amp;<a class='struct' href='../../gfx/display_list/struct.ClippingRegion.html' title='gfx::display_list::ClippingRegion'>ClippingRegion</a>)</code></h4>
<div class='docblock'><p>Adds the display items necessary to paint the box shadow of this fragment to the display list if necessary. <a href="../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_display_list_for_box_shadow_if_applicable">Read more</a></p>
</div><h4 id='method.build_display_list_for_borders_if_applicable' class='method'><code>fn <a href='../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_display_list_for_borders_if_applicable' class='fnname'>build_display_list_for_borders_if_applicable</a>(&amp;self, state: &amp;mut <a class='struct' href='../../layout/display_list_builder/struct.DisplayListBuildState.html' title='layout::display_list_builder::DisplayListBuildState'>DisplayListBuildState</a>, style: &amp;<a class='struct' href='../../style/properties/struct.ServoComputedValues.html' title='style::properties::ServoComputedValues'>ServoComputedValues</a>, border_painting_mode: <a class='enum' href='../../layout/display_list_builder/enum.BorderPaintingMode.html' title='layout::display_list_builder::BorderPaintingMode'>BorderPaintingMode</a>, bounds: &amp;<a class='struct' href='../../euclid/rect/struct.Rect.html' title='euclid::rect::Rect'>Rect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, display_list_section: <a class='enum' href='../../gfx/display_list/enum.DisplayListSection.html' title='gfx::display_list::DisplayListSection'>DisplayListSection</a>, clip: &amp;<a class='struct' href='../../gfx/display_list/struct.ClippingRegion.html' title='gfx::display_list::ClippingRegion'>ClippingRegion</a>)</code></h4>
<div class='docblock'><p>Adds the display items necessary to paint the borders of this fragment to a display list if necessary. <a href="../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_display_list_for_borders_if_applicable">Read more</a></p>
</div><h4 id='method.build_display_list_for_outline_if_applicable' class='method'><code>fn <a href='../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_display_list_for_outline_if_applicable' class='fnname'>build_display_list_for_outline_if_applicable</a>(&amp;self, state: &amp;mut <a class='struct' href='../../layout/display_list_builder/struct.DisplayListBuildState.html' title='layout::display_list_builder::DisplayListBuildState'>DisplayListBuildState</a>, style: &amp;<a class='struct' href='../../style/properties/struct.ServoComputedValues.html' title='style::properties::ServoComputedValues'>ServoComputedValues</a>, bounds: &amp;<a class='struct' href='../../euclid/rect/struct.Rect.html' title='euclid::rect::Rect'>Rect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, clip: &amp;<a class='struct' href='../../gfx/display_list/struct.ClippingRegion.html' title='gfx::display_list::ClippingRegion'>ClippingRegion</a>)</code></h4>
<div class='docblock'><p>Adds the display items necessary to paint the outline of this fragment to the display list if necessary. <a href="../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_display_list_for_outline_if_applicable">Read more</a></p>
</div><h4 id='method.build_debug_borders_around_text_fragments' class='method'><code>fn <a href='../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_debug_borders_around_text_fragments' class='fnname'>build_debug_borders_around_text_fragments</a>(&amp;self, state: &amp;mut <a class='struct' href='../../layout/display_list_builder/struct.DisplayListBuildState.html' title='layout::display_list_builder::DisplayListBuildState'>DisplayListBuildState</a>, style: &amp;<a class='struct' href='../../style/properties/struct.ServoComputedValues.html' title='style::properties::ServoComputedValues'>ServoComputedValues</a>, stacking_relative_border_box: &amp;<a class='struct' href='../../euclid/rect/struct.Rect.html' title='euclid::rect::Rect'>Rect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, stacking_relative_content_box: &amp;<a class='struct' href='../../euclid/rect/struct.Rect.html' title='euclid::rect::Rect'>Rect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, text_fragment: &amp;<a class='struct' href='../../layout/fragment/struct.ScannedTextFragmentInfo.html' title='layout::fragment::ScannedTextFragmentInfo'>ScannedTextFragmentInfo</a>, clip: &amp;<a class='struct' href='../../gfx/display_list/struct.ClippingRegion.html' title='gfx::display_list::ClippingRegion'>ClippingRegion</a>)</code></h4>
<div class='docblock'><p>Adds display items necessary to draw debug boxes around a scanned text fragment.</p>
</div><h4 id='method.build_debug_borders_around_fragment' class='method'><code>fn <a href='../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_debug_borders_around_fragment' class='fnname'>build_debug_borders_around_fragment</a>(&amp;self, state: &amp;mut <a class='struct' href='../../layout/display_list_builder/struct.DisplayListBuildState.html' title='layout::display_list_builder::DisplayListBuildState'>DisplayListBuildState</a>, stacking_relative_border_box: &amp;<a class='struct' href='../../euclid/rect/struct.Rect.html' title='euclid::rect::Rect'>Rect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, clip: &amp;<a class='struct' href='../../gfx/display_list/struct.ClippingRegion.html' title='gfx::display_list::ClippingRegion'>ClippingRegion</a>)</code></h4>
<div class='docblock'><p>Adds display items necessary to draw debug boxes around this fragment.</p>
</div><h4 id='method.adjust_clip_for_style' class='method'><code>fn <a href='../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.adjust_clip_for_style' class='fnname'>adjust_clip_for_style</a>(&amp;self, parent_clip: &amp;mut <a class='struct' href='../../gfx/display_list/struct.ClippingRegion.html' title='gfx::display_list::ClippingRegion'>ClippingRegion</a>, stacking_relative_border_box: &amp;<a class='struct' href='../../euclid/rect/struct.Rect.html' title='euclid::rect::Rect'>Rect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;)</code></h4>
<div class='docblock'><p>Adjusts the clipping rectangle for a fragment to take the <code>clip</code> property into account per CSS 2.1 § 11.1.2. <a href="../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.adjust_clip_for_style">Read more</a></p>
</div><h4 id='method.build_display_items_for_selection_if_necessary' class='method'><code>fn <a href='../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_display_items_for_selection_if_necessary' class='fnname'>build_display_items_for_selection_if_necessary</a>(&amp;self, state: &amp;mut <a class='struct' href='../../layout/display_list_builder/struct.DisplayListBuildState.html' title='layout::display_list_builder::DisplayListBuildState'>DisplayListBuildState</a>, stacking_relative_border_box: &amp;<a class='struct' href='../../euclid/rect/struct.Rect.html' title='euclid::rect::Rect'>Rect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, display_list_section: <a class='enum' href='../../gfx/display_list/enum.DisplayListSection.html' title='gfx::display_list::DisplayListSection'>DisplayListSection</a>, clip: &amp;<a class='struct' href='../../gfx/display_list/struct.ClippingRegion.html' title='gfx::display_list::ClippingRegion'>ClippingRegion</a>)</code></h4>
<div class='docblock'><p>Builds the display items necessary to paint the selection and/or caret for this fragment, if any. <a href="../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_display_items_for_selection_if_necessary">Read more</a></p>
</div><h4 id='method.build_display_list' class='method'><code>fn <a href='../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_display_list' class='fnname'>build_display_list</a>(&amp;mut self, state: &amp;mut <a class='struct' href='../../layout/display_list_builder/struct.DisplayListBuildState.html' title='layout::display_list_builder::DisplayListBuildState'>DisplayListBuildState</a>, stacking_relative_flow_origin: &amp;<a class='struct' href='../../euclid/point/struct.Point2D.html' title='euclid::point::Point2D'>Point2D</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, relative_containing_block_size: &amp;<a class='struct' href='../../style/logical_geometry/struct.LogicalSize.html' title='style::logical_geometry::LogicalSize'>LogicalSize</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, relative_containing_block_mode: <a class='struct' href='../../style/logical_geometry/struct.WritingMode.html' title='style::logical_geometry::WritingMode'>WritingMode</a>, border_painting_mode: <a class='enum' href='../../layout/display_list_builder/enum.BorderPaintingMode.html' title='layout::display_list_builder::BorderPaintingMode'>BorderPaintingMode</a>, display_list_section: <a class='enum' href='../../gfx/display_list/enum.DisplayListSection.html' title='gfx::display_list::DisplayListSection'>DisplayListSection</a>, clip: &amp;<a class='struct' href='../../gfx/display_list/struct.ClippingRegion.html' title='gfx::display_list::ClippingRegion'>ClippingRegion</a>, stacking_relative_display_port: &amp;<a class='struct' href='../../euclid/rect/struct.Rect.html' title='euclid::rect::Rect'>Rect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;)</code></h4>
<div class='docblock'><p>Adds the display items for this fragment to the given display list. <a href="../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_display_list">Read more</a></p>
</div><h4 id='method.build_fragment_type_specific_display_items' class='method'><code>fn <a href='../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_fragment_type_specific_display_items' class='fnname'>build_fragment_type_specific_display_items</a>(&amp;mut self, state: &amp;mut <a class='struct' href='../../layout/display_list_builder/struct.DisplayListBuildState.html' title='layout::display_list_builder::DisplayListBuildState'>DisplayListBuildState</a>, stacking_relative_border_box: &amp;<a class='struct' href='../../euclid/rect/struct.Rect.html' title='euclid::rect::Rect'>Rect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, clip: &amp;<a class='struct' href='../../gfx/display_list/struct.ClippingRegion.html' title='gfx::display_list::ClippingRegion'>ClippingRegion</a>)</code></h4>
<div class='docblock'><p>A helper method that <code>build_display_list</code> calls to create per-fragment-type display items.</p>
</div><h4 id='method.create_stacking_context' class='method'><code>fn <a href='../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.create_stacking_context' class='fnname'>create_stacking_context</a>(&amp;self, id: <a class='struct' href='../../gfx_traits/struct.StackingContextId.html' title='gfx_traits::StackingContextId'>StackingContextId</a>, base_flow: &amp;<a class='struct' href='../../layout/flow/struct.BaseFlow.html' title='layout::flow::BaseFlow'>BaseFlow</a>, scroll_policy: <a class='enum' href='../../gfx_traits/enum.ScrollPolicy.html' title='gfx_traits::ScrollPolicy'>ScrollPolicy</a>, mode: <a class='enum' href='../../layout/display_list_builder/enum.StackingContextCreationMode.html' title='layout::display_list_builder::StackingContextCreationMode'>StackingContextCreationMode</a>) -&gt; <a class='struct' href='../../alloc/boxed/struct.Box.html' title='alloc::boxed::Box'>Box</a>&lt;<a class='struct' href='../../gfx/display_list/struct.StackingContext.html' title='gfx::display_list::StackingContext'>StackingContext</a>&gt;</code></h4>
<div class='docblock'><p>Creates a stacking context for associated fragment.</p>
</div><h4 id='method.adjust_clipping_region_for_children' class='method'><code>fn <a href='../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.adjust_clipping_region_for_children' class='fnname'>adjust_clipping_region_for_children</a>(&amp;self, current_clip: &amp;mut <a class='struct' href='../../gfx/display_list/struct.ClippingRegion.html' title='gfx::display_list::ClippingRegion'>ClippingRegion</a>, stacking_relative_border_box: &amp;<a class='struct' href='../../euclid/rect/struct.Rect.html' title='euclid::rect::Rect'>Rect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;)</code></h4>
<div class='docblock'><p>Adjusts the clipping region for descendants of this fragment as appropriate.</p>
</div><h4 id='method.build_display_list_for_text_fragment' class='method'><code>fn <a href='../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_display_list_for_text_fragment' class='fnname'>build_display_list_for_text_fragment</a>(&amp;self, state: &amp;mut <a class='struct' href='../../layout/display_list_builder/struct.DisplayListBuildState.html' title='layout::display_list_builder::DisplayListBuildState'>DisplayListBuildState</a>, text_fragment: &amp;<a class='struct' href='../../layout/fragment/struct.ScannedTextFragmentInfo.html' title='layout::fragment::ScannedTextFragmentInfo'>ScannedTextFragmentInfo</a>, text_color: <a class='struct' href='../../cssparser/color/struct.RGBA.html' title='cssparser::color::RGBA'>RGBA</a>, stacking_relative_content_box: &amp;<a class='struct' href='../../euclid/rect/struct.Rect.html' title='euclid::rect::Rect'>Rect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, shadow_blur_radius: <a class='enum' href='../../core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, offset: &amp;<a class='struct' href='../../euclid/point/struct.Point2D.html' title='euclid::point::Point2D'>Point2D</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, clip: &amp;<a class='struct' href='../../gfx/display_list/struct.ClippingRegion.html' title='gfx::display_list::ClippingRegion'>ClippingRegion</a>)</code></h4>
<div class='docblock'><p>Creates the text display item for one text fragment. This can be called multiple times for one fragment if there are text shadows. <a href="../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_display_list_for_text_fragment">Read more</a></p>
</div><h4 id='method.build_display_list_for_text_decoration' class='method'><code>fn <a href='../../layout/display_list_builder/trait.FragmentDisplayListBuilding.html#tymethod.build_display_list_for_text_decoration' class='fnname'>build_display_list_for_text_decoration</a>(&amp;self, state: &amp;mut <a class='struct' href='../../layout/display_list_builder/struct.DisplayListBuildState.html' title='layout::display_list_builder::DisplayListBuildState'>DisplayListBuildState</a>, color: &amp;<a class='struct' href='../../cssparser/color/struct.RGBA.html' title='cssparser::color::RGBA'>RGBA</a>, stacking_relative_box: &amp;<a class='struct' href='../../style/logical_geometry/struct.LogicalRect.html' title='style::logical_geometry::LogicalRect'>LogicalRect</a>&lt;<a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>&gt;, clip: &amp;<a class='struct' href='../../gfx/display_list/struct.ClippingRegion.html' title='gfx::display_list::ClippingRegion'>ClippingRegion</a>, blur_radius: <a class='struct' href='../../app_units/app_unit/struct.Au.html' title='app_units::app_unit::Au'>Au</a>)</code></h4>
<div class='docblock'><p>Creates the display item for a text decoration: underline, overline, or line-through.</p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class='trait' href='../../rustc_serialize/serialize/trait.Encodable.html' title='rustc_serialize::serialize::Encodable'>Encodable</a> for <a class='struct' href='../../layout/struct.Fragment.html' title='layout::Fragment'>Fragment</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-4973' class='srclink' href='../../src/layout/fragment.rs.html#132-140' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.encode' class='method'><code>fn <a href='../../rustc_serialize/serialize/trait.Encodable.html#tymethod.encode' class='fnname'>encode</a>&lt;S:&nbsp;<a class='trait' href='../../rustc_serialize/serialize/trait.Encoder.html' title='rustc_serialize::serialize::Encoder'>Encoder</a>&gt;(&amp;self, e: &amp;mut S) -&gt; <a class='enum' href='../../core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='../../std/primitive.tuple.html'>()</a>,&nbsp;S::Error&gt;</code></h4>
</div><h3 class='impl'><span class='in-band'><code>impl <a class='trait' href='../../core/fmt/trait.Debug.html' title='core::fmt::Debug'>Debug</a> for <a class='struct' href='../../layout/struct.Fragment.html' title='layout::Fragment'>Fragment</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-5998' class='srclink' href='../../src/layout/fragment.rs.html#2609-2638' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.fmt' class='method'><code>fn <a href='../../core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class='struct' href='../../core/fmt/struct.Formatter.html' title='core::fmt::Formatter'>Formatter</a>) -&gt; <a class='type' href='../../core/fmt/type.Result.html' title='core::fmt::Result'>Result</a></code></h4>
<div class='docblock'><p>Formats the value using the given formatter.</p>
</div></div><h3 id='derived_implementations'>Derived Implementations </h3><h3 class='impl'><span class='in-band'><code>impl <a class='trait' href='../../core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a> for <a class='struct' href='../../layout/struct.Fragment.html' title='layout::Fragment'>Fragment</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-4957' class='srclink' href='../../src/layout/fragment.rs.html#80' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.clone' class='method'><code>fn <a href='../../core/clone/trait.Clone.html#tymethod.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class='struct' href='../../layout/struct.Fragment.html' title='layout::Fragment'>Fragment</a></code></h4>
<div class='docblock'><p>Returns a copy of the value. <a href="../../core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id='method.clone_from' class='method'><code>fn <a href='../../core/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: &amp;Self)</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></h4>
<div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="../../core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "layout";
        window.playgroundUrl = "";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    
    <script defer src="../../search-index.js"></script>
</body>
</html>