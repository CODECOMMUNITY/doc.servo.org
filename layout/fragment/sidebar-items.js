initSidebarItems({"constant":[["HAS_LAYER","Whether this fragment has a layer."],["INTRINSIC_INLINE_SIZE_INCLUDES_BORDER",""],["INTRINSIC_INLINE_SIZE_INCLUDES_MARGINS",""],["INTRINSIC_INLINE_SIZE_INCLUDES_PADDING",""],["INTRINSIC_INLINE_SIZE_INCLUDES_SPECIFIED",""],["REQUIRES_LINE_BREAK_AFTERWARD_IF_WRAPPING_ON_NEWLINES","Whether a line break is required after this fragment if wrapping on newlines (e.g. if `white-space: pre` is in effect)."],["RETRY_AT_CHARACTER_BOUNDARIES","True if we should attempt to split at character boundaries if this split fails. This is used to implement `overflow-wrap: break-word`."],["SELECTED","Is this fragment selected?"],["STARTS_LINE","True if this is the first fragment on the line."]],"enum":[["CoordinateSystem","The coordinate system used in `stacking_relative_border_box()`. See the documentation of that method for details."],["GeneratedContentInfo","Information for generated content."],["SpecificFragmentInfo","Info specific to the kind of fragment."],["WhitespaceStrippingResult",""]],"fn":[["clamp_size","Clamp a value obtained from style_length, based on min / max lengths."]],"struct":[["CanvasFragmentInfo",""],["Fragment","Fragments (`struct Fragment`) are the leaves of the layout tree. They cannot position themselves. In general, fragments do not have a simple correspondence with CSS fragments in the specification:"],["FragmentFlags",""],["IframeFragmentInfo","A fragment that represents an inline frame (iframe). This stores the pipeline ID so that the size of this iframe can be communicated via the constellation to the iframe's own layout thread."],["ImageFragmentInfo","A fragment that represents a replaced content image and its accompanying borders, shadows, etc."],["InlineAbsoluteFragmentInfo","An inline fragment that establishes an absolute containing block for its descendants (i.e. a positioned inline fragment)."],["InlineAbsoluteHypotheticalFragmentInfo","A hypothetical box (see CSS 2.1 ยง 10.3.7) for an absolutely-positioned block that was declared with `display: inline;`."],["InlineBlockFragmentInfo","A fragment that represents an inline-block element."],["InlineStyleIterator",""],["Overflow","The overflow area. We need two different notions of overflow: paint overflow and scrollable overflow."],["QuantitiesIncludedInIntrinsicInlineSizes",""],["ReplacedImageFragmentInfo",""],["ScannedTextFlags",""],["ScannedTextFragmentInfo","A scanned text fragment represents a single run of text with a distinct style. A `TextFragment` may be split into two or more fragments across line breaks. Several `TextFragment`s may correspond to a single DOM text node. Split text fragments are implemented by referring to subsets of a single `TextRun` object."],["SpeculatedInlineContentEdgeOffsets","Specified distances from the margin edge of a block to its content in the inline direction. These are returned by `guess_inline_content_edge_offsets()` and are used in the float placement speculation logic."],["SplitInfo","Describes how to split a fragment. This is used during line breaking as part of the return value of `find_split_info_for_inline_size()`."],["SplitOptions",""],["SplitResult","Describes how to split a fragment into two. This contains up to two `SplitInfo`s."],["TableColumnFragmentInfo","A fragment that represents a table column."],["TruncationResult","Describes how a fragment should be truncated."],["UnscannedTextFragmentInfo","Data for an unscanned text fragment. Unscanned text fragments are the results of flow construction that have not yet had their inline-size determined."]],"trait":[["FragmentBorderBoxIterator","A top-down fragment border box iteration handler."]]});